import { Subscriptions } from "@ringcentral/subscriptions";
import RcWsExtension from "@rc-ex/ws";
const WebSocketExtension = RcWsExtension.default ?? RcWsExtension;
type WebSocketExtension = InstanceType<typeof WebSocketExtension>;
import * as fs from "fs";
import * as path from "path";

import type { OpenClawConfig } from "openclaw/plugin-sdk";
import { resolveMentionGatingWithBypass } from "openclaw/plugin-sdk";

import type { ResolvedRingCentralAccount } from "./accounts.js";
import { getRingCentralSDK } from "./auth.js";
import {
  sendRingCentralMessage,
  updateRingCentralMessage,
  deleteRingCentralMessage,
  downloadRingCentralAttachment,
  uploadRingCentralAttachment,
  getRingCentralChat,
  getRingCentralUser,
  extractRcApiError,
  formatRcApiError,
} from "./api.js";
import { getRingCentralRuntime } from "./runtime.js";
import { startChatCacheSync, stopChatCacheSync } from "./chat-cache.js";
import type {
  RingCentralWebhookEvent,
  RingCentralEventBody,
  RingCentralAttachment,
  RingCentralMention,
} from "./types.js";

export type RingCentralLogger = {
  debug: (message: string) => void;
  info: (message: string) => void;
  warn: (message: string) => void;
  error: (message: string) => void;
};

/**
 * @deprecated Use OpenClaw logger (getLogger(core)) instead.
 * Kept for backward compatibility but no longer used internally.
 */
export type RingCentralRuntimeEnv = {
  log?: (message: string) => void;
  error?: (message: string) => void;
};

function createLogger(core: RingCentralCoreRuntime): RingCentralLogger {
  return core.logging.getChildLogger({ plugin: "ringcentral" });
}

// Track recently sent message IDs to avoid processing bot's own replies
const recentlySentMessageIds = new Set<string>();
const MESSAGE_ID_TTL = 60000; // 60 seconds

// Reconnection settings
const RECONNECT_INITIAL_DELAY = 5000; // 5 seconds (increased to avoid 429)
const RECONNECT_MAX_DELAY = 300000; // 5 minutes (increased for rate limiting)
const RECONNECT_MAX_ATTEMPTS = 10; // Increased for long-term resilience
const RATE_LIMIT_BACKOFF = 60000; // 1 minute backoff on 429
const WS_HEALTH_CHECK_INTERVAL = 60000; // Check WebSocket health every 60 seconds

// WebSocket singleton per account to avoid hammering /oauth/wstoken.
// @ringcentral/subscriptions + @rc-ex/ws can swallow initial connect errors and
// repeated new Subscriptions()/newWsExtension() will trigger new wstoken calls.
type WsManager = {
  key: string;
  sdk: any;
  subscriptions: Subscriptions;
  rc: any;
  wsExt: WebSocketExtension;
  connectPromise?: Promise<void>;
  lastConnectAt?: number;
};

const wsManagers = new Map<string, WsManager>();

function buildWsManagerKey(account: ResolvedRingCentralAccount): string {
  // Changes in credentials should force a new WS manager.
  return `${account.clientId}:${account.server}:${account.jwt?.slice(0, 20)}`;
}

async function getOrCreateWsManager(
  account: ResolvedRingCentralAccount,
  logger: RingCentralLogger,
): Promise<WsManager> {
  const key = buildWsManagerKey(account);
  const cached = wsManagers.get(account.accountId);
  if (cached && cached.key === key) return cached;

  // Replace cache entry on credential change.
  const sdk = await getRingCentralSDK(account);
  const subscriptions = new Subscriptions({ sdk });
  await (subscriptions as any).init?.();

  const wsExt = new WebSocketExtension({
    debugMode: true,
    autoRecover: { enabled: false },
  });

  const rc = (subscriptions as any).rc;
  if (!rc || typeof rc.installExtension !== "function") {
    throw new Error("Subscriptions.rc.installExtension is unavailable; cannot install WS extension");
  }

  logger.debug(`[${account.accountId}] Installing @rc-ex/ws extension (singleton)...`);
  await rc.installExtension(wsExt);

  const mgr: WsManager = { key, sdk, subscriptions, rc, wsExt };
  wsManagers.set(account.accountId, mgr);
  return mgr;
}

async function ensureWsConnected(
  mgr: WsManager,
  account: ResolvedRingCentralAccount,
  logger: RingCentralLogger,
): Promise<void> {
  // If already connected/open, nothing to do.
  const ws = mgr.wsExt.ws;
  if (ws && (ws.readyState === 0 || ws.readyState === 1)) {
    return;
  }
  if (mgr.connectPromise) {
    return mgr.connectPromise;
  }

  mgr.connectPromise = (async () => {
    logger.debug(`[${account.accountId}] Forcing WS connect() (singleton)...`);
    await mgr.wsExt.connect(false);
    mgr.lastConnectAt = Date.now();
    if (!mgr.wsExt.ws) {
      throw new Error("WS connect() returned but wsExt.ws is still undefined");
    }
  })();

  try {
    await mgr.connectPromise;
  } finally {
    mgr.connectPromise = undefined;
  }
}


function trackSentMessageId(messageId: string): void {
  recentlySentMessageIds.add(messageId);
  setTimeout(() => recentlySentMessageIds.delete(messageId), MESSAGE_ID_TTL);
}

function isOwnSentMessage(messageId: string): boolean {
  return recentlySentMessageIds.has(messageId);
}

export type RingCentralMonitorOptions = {
  account: ResolvedRingCentralAccount;
  config: OpenClawConfig;
  runtime: RingCentralRuntimeEnv;
  abortSignal: AbortSignal;
  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
};

type RingCentralCoreRuntime = ReturnType<typeof getRingCentralRuntime>;

// Shared logger instance (lazy initialized)
let sharedLogger: RingCentralLogger | null = null;

function getLogger(core: RingCentralCoreRuntime): RingCentralLogger {
  if (!sharedLogger) {
    sharedLogger = createLogger(core);
  }
  return sharedLogger;
}

function logVerbose(
  core: RingCentralCoreRuntime,
  message: string,
) {
  if (core.logging.shouldLogVerbose()) {
    getLogger(core).debug(message);
  }
}

/**
 * Save group chat message to workspace memory file.
 * File path: ${workspace}/memory/chats/YYYY-MM-DD/${chatId}.md
 */
async function saveGroupChatMessage(params: {
  workspace: string;
  chatId: string;
  chatName?: string;
  senderId: string;
  messageText: string;
  timestamp?: string;
  logger: RingCentralLogger;
}): Promise<void> {
  const { workspace, chatId, chatName, senderId, messageText, timestamp, logger } = params;

  if (!workspace) {
    logger.debug(`[ringcentral] Cannot save chat message: workspace not configured`);
    return;
  }

  try {
    // Parse timestamp or use current time
    const msgDate = timestamp ? new Date(timestamp) : new Date();
    const dateStr = msgDate.toISOString().split("T")[0]; // YYYY-MM-DD
    const timeStr = msgDate.toLocaleTimeString("zh-CN", {
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
      timeZone: "Asia/Shanghai",
    });

    // Build file path
    const chatDir = path.join(workspace, "memory", "chats", dateStr);
    const filePath = path.join(chatDir, `${chatId}.md`);

    // Ensure directory exists
    await fs.promises.mkdir(chatDir, { recursive: true });

    // Format message entry
    const header = chatName ? `# ${chatName} (${chatId})\n\n` : `# Chat ${chatId}\n\n`;
    const entry = `## ${timeStr} - ${senderId}\n${messageText}\n\n---\n\n`;

    // Check if file exists; if not, write header first
    let content = entry;
    try {
      await fs.promises.access(filePath);
      // File exists, just append
    } catch {
      // File doesn't exist, prepend header
      content = header + entry;
    }

    // Append to file
    await fs.promises.appendFile(filePath, content === entry ? entry : content, "utf-8");

    logger.debug(`[ringcentral] Saved chat message to ${filePath}`);
  } catch (err) {
    logger.error(`[ringcentral] Failed to save chat message: ${String(err)}`);
  }
}

function normalizeUserId(raw?: string | null): string {
  const trimmed = raw?.trim() ?? "";
  if (!trimmed) return "";
  return trimmed.toLowerCase();
}

export function isSenderAllowed(
  senderId: string,
  allowFrom: string[],
): boolean {
  if (allowFrom.includes("*")) return true;
  const normalizedSenderId = normalizeUserId(senderId);
  return allowFrom.some((entry) => {
    const normalized = String(entry).trim().toLowerCase();
    if (!normalized) return false;
    if (normalized === normalizedSenderId) return true;
    if (normalized.replace(/^(ringcentral|rc):/i, "") === normalizedSenderId) return true;
    if (normalized.replace(/^user:/i, "") === normalizedSenderId) return true;
    return false;
  });
}

function resolveGroupConfig(params: {
  groupId: string;
  groupName?: string | null;
  groups?: Record<string, { requireMention?: boolean; allow?: boolean; enabled?: boolean; users?: Array<string | number>; systemPrompt?: string }>;
}) {
  const { groupId, groupName, groups } = params;
  const entries = groups ?? {};
  const keys = Object.keys(entries);
  if (keys.length === 0) {
    return { entry: undefined, allowlistConfigured: false };
  }
  const normalizedName = groupName?.trim().toLowerCase();
  const candidates = [groupId, groupName ?? "", normalizedName ?? ""].filter(Boolean);
  let entry = candidates.map((candidate) => entries[candidate]).find(Boolean);
  if (!entry && normalizedName) {
    entry = entries[normalizedName];
  }
  const fallback = entries["*"];
  return { entry: entry ?? fallback, allowlistConfigured: true, fallback };
}

function extractMentionInfo(mentions: RingCentralMention[], botExtensionId?: string | null) {
  const personMentions = mentions.filter((entry) => entry.type === "Person");
  const hasAnyMention = personMentions.length > 0;
  const wasMentioned = botExtensionId
    ? personMentions.some((entry) => entry.id === botExtensionId)
    : false;
  return { hasAnyMention, wasMentioned };
}

function resolveBotDisplayName(params: {
  accountName?: string;
  agentId: string;
  config: OpenClawConfig;
}): string {
  const { accountName, agentId, config } = params;
  if (accountName?.trim()) return accountName.trim();
  const agent = config.agents?.list?.find((a) => a.id === agentId);
  if (agent?.name?.trim()) return agent.name.trim();
  return "OpenClaw";
}

async function processWebSocketEvent(params: {
  event: RingCentralWebhookEvent;
  account: ResolvedRingCentralAccount;
  config: OpenClawConfig;
  runtime: RingCentralRuntimeEnv;
  core: RingCentralCoreRuntime;
  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
  ownerId?: string;
}): Promise<void> {
  const { event, account, config, runtime, core, statusSink, ownerId } = params;
  
  const eventBody = event.body;
  if (!eventBody) return;

  // Check event type - can be from eventType field or inferred from event path
  const eventType = eventBody.eventType;
  const eventPath = event.event ?? "";
  const isPostEvent = eventPath.includes("/glip/posts") || eventPath.includes("/team-messaging") || eventType === "PostAdded";
  
  if (!isPostEvent) {
    return;
  }

  statusSink?.({ lastInboundAt: Date.now() });

  await processMessageWithPipeline({
    eventBody,
    account,
    config,
    runtime,
    core,
    statusSink,
    ownerId,
  });
}

async function processMessageWithPipeline(params: {
  eventBody: RingCentralEventBody;
  account: ResolvedRingCentralAccount;
  config: OpenClawConfig;
  runtime: RingCentralRuntimeEnv;
  core: RingCentralCoreRuntime;
  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
  ownerId?: string;
}): Promise<void> {
  const { eventBody, account, config, runtime, core, statusSink, ownerId } = params;
  const logger = getLogger(core);
  const mediaMaxMb = account.config.mediaMaxMb ?? 20;
  
  const chatId = eventBody.groupId ?? "";
  if (!chatId) return;

  const senderId = eventBody.creatorId ?? "";
  const messageText = (eventBody.text ?? "").trim();
  const attachments = eventBody.attachments ?? [];
  const hasMedia = attachments.length > 0;
  const rawBody = messageText || (hasMedia ? "<media:attachment>" : "");
  if (!rawBody) return;

  // Skip bot's own messages to avoid infinite loop
  // Check 1: Skip if this is a message we recently sent
  const messageId = eventBody.id ?? "";
  if (messageId && isOwnSentMessage(messageId)) {
    logVerbose(core, `skip own sent message: ${messageId}`);
    return;
  }
  
  // Check 2: Skip typing/thinking indicators (pattern-based)
  if (rawBody.includes("thinking...") || rawBody.includes("typing...")) {
    logVerbose(core, "skip typing indicator message");
    return;
  }
  
  // In JWT mode (selfOnly), only accept messages from the JWT user themselves
  // This is because the bot uses the JWT user's identity, so we're essentially
  // having a conversation with ourselves (the AI assistant)
  const selfOnly = account.config.selfOnly !== false; // default true
  logger.debug(`[${account.accountId}] Processing message: senderId=${senderId}, ownerId=${ownerId}, selfOnly=${selfOnly}, chatId=${chatId}`);
  
  if (selfOnly && ownerId) {
    if (senderId !== ownerId) {
      logVerbose(core, `ignore message from non-owner: ${senderId} (selfOnly mode)`);
      return;
    }
  }
  
  logger.debug(`[${account.accountId}] Message passed selfOnly check`);

  // Fetch chat info to determine type
  let chatType = "Group";
  let chatName: string | undefined;
  let chatInfo: any | undefined;
  try {
    chatInfo = await getRingCentralChat({ account, chatId });
    chatType = chatInfo?.type ?? "Group";
    chatName = chatInfo?.name ?? undefined;

    // OpenClaw logger respects configured log level - debug output controlled by openclaw config
    logger.debug(
      `[${account.accountId}] chatInfo: id=${chatId} type=${chatInfo?.type ?? null} ` +
        `name=${JSON.stringify(chatInfo?.name ?? null)} members=${JSON.stringify(chatInfo?.members ?? null)} ` +
        `description=${JSON.stringify(chatInfo?.description ?? null)}`,
    );
  } catch (err) {
    // If we can't fetch chat info, assume it's a group.
    logger.error(`[${account.accountId}] getRingCentralChat failed: ${String(err)}`);
  }

  // Personal, PersonalChat, Direct are all DM types
  const isPersonalChat = chatType === "Personal" || chatType === "PersonalChat";
  const isDirectChat = chatType === "Direct";
  const isGroup = !(isPersonalChat || isDirectChat);

  // Only track configured groups; ignore any other group/team chats.
  // NOTE: Direct/Personal chats are NOT subject to this filter.
  const configuredGroups = account.config.groups ?? {};
  const hasConfiguredGroups = Object.keys(configuredGroups).length > 0;
  const isTrackedGroup = !isGroup
    ? true
    : Boolean(configuredGroups[chatId] || configuredGroups[String(chatId)] || configuredGroups[chatName ?? ""]);
  if (isGroup && hasConfiguredGroups && !isTrackedGroup) {
    logVerbose(core, `ignore group chat not in configured groups: chatId=${chatId}`);
    return;
  }

  // Session key should be per conversation id (RingCentral chatId)
  // NOTE: keep peer.kind stable for group vs dm.
  // Session routing
  // - Group/Team: route by conversation id (chatId)
  // - DM/Person: route by the *peer userId* (not chatId)
  //   Reason: some DM payloads/types can collapse to a "personal"/self chat id which would
  //   incorrectly merge multiple DMs into one session.
  const ownerIdNorm = normalizeUserId(ownerId);
  const senderIdNorm = normalizeUserId(senderId);

  // Best-effort: compute the other participant id from chatInfo.members when available.
  // RingCentral DM members usually contains 2 userIds.
  const chatMembers: string[] = Array.isArray((chatInfo as any)?.members)
    ? ((chatInfo as any).members as any[]).map((v) => normalizeUserId(String(v)))
    : [];
  const dmPeerFromMembers = chatMembers.find((id) => id && id !== ownerIdNorm) || "";

  const dmPeerUserId = !isGroup
    ? (dmPeerFromMembers || (senderIdNorm !== ownerIdNorm ? senderIdNorm : ""))
    : "";

  // Map RingCentral chat types to openclaw peerKind:
  // - Personal/Direct -> "dm" (direct message)
  // - Group -> "group" (small group chat, 3-16 people)
  // - Team -> "channel" (named team chat, similar to Slack channel)
  const peerKind: "dm" | "group" | "channel" = isGroup
    ? chatType === "Team"
      ? "channel"
      : "group"
    : "dm";

  const route = core.channel.routing.resolveAgentRoute({
    cfg: config,
    channel: "ringcentral",
    accountId: account.accountId,
    peer: {
      kind: peerKind,
      id: isGroup ? chatId : (dmPeerUserId || chatId),
    },
  });

  logger.debug(`[${account.accountId}] Chat type: ${chatType}, isGroup: ${isGroup}`);

  // In selfOnly mode, only allow "Personal" chat (conversation with yourself)
  if (selfOnly && !isPersonalChat) {
    logVerbose(core, `ignore non-personal chat in selfOnly mode: chatType=${chatType}`);
    return;
  }

  const defaultGroupPolicy = config.channels?.defaults?.groupPolicy;
  const groupPolicy = account.config.groupPolicy ?? defaultGroupPolicy ?? "allowlist";
  const groupConfigResolved = resolveGroupConfig({
    groupId: chatId,
    groupName: chatName ?? null,
    groups: account.config.groups ?? undefined,
  });
  const groupEntry = groupConfigResolved.entry;
  const groupUsers = groupEntry?.users ?? account.config.groupAllowFrom ?? [];
  let effectiveWasMentioned: boolean | undefined;

  if (isGroup) {
    logger.debug(`[${account.accountId}] Entering group processing: chatId=${chatId}, groupPolicy=${groupPolicy}, groupEntry=${!!groupEntry}`);
    if (groupPolicy === "disabled") {
      logger.debug(`[${account.accountId}] DROP: groupPolicy=disabled`);
      return;
    }
    const groupAllowlistConfigured = groupConfigResolved.allowlistConfigured;
    const groupAllowed =
      Boolean(groupEntry) || Boolean((account.config.groups ?? {})["*"]);
    logger.debug(`[${account.accountId}] Allowlist check: configured=${groupAllowlistConfigured}, allowed=${groupAllowed}`);
    if (groupPolicy === "allowlist") {
      if (!groupAllowlistConfigured) {
        logger.debug(`[${account.accountId}] DROP: no allowlist configured`);
        return;
      }
      if (!groupAllowed) {
        logger.debug(`[${account.accountId}] DROP: not in allowlist`);
        return;
      }
    }
    if (groupEntry?.enabled === false || groupEntry?.allow === false) {
      logVerbose(core, `drop group message (chat disabled, chat=${chatId})`);
      return;
    }

    if (groupUsers.length > 0) {
      const ok = isSenderAllowed(senderId, groupUsers.map((v) => String(v)));
      if (!ok) {
        logVerbose(core, `drop group message (sender not allowed, ${senderId})`);
        return;
      }
    }

    // Save group chat message to workspace for analysis/logging
    // This happens AFTER allowlist check but BEFORE mention check,
    // so we log all messages from monitored groups regardless of AI response
    const workspace = account.config.workspace ?? (config.agents as any)?.defaults?.workspace;
    logger.debug(`[${account.accountId}] Group message logging: workspace=${workspace}, chatId=${chatId}, senderId=${senderId}`);
    if (workspace) {
      void saveGroupChatMessage({
        workspace,
        chatId,
        chatName,
        senderId,
        messageText: rawBody,
        timestamp: eventBody.creationTime,
        logger,
      });
    } else {
      logger.debug(`[${account.accountId}] Skipping chat log: no workspace configured`);
    }

    // Update session metadata for allowed groups only (after allowlist check passes)
    try {
      const storePath = core.channel.session.resolveStorePath(config.session?.store, {
        agentId: route.agentId,
      });

      // If RingCentral chat has no name (often true for Group chats), create a stable label
      // by resolving up to 3 member first names and joining with commas.
      let metaLabel: string;
      if (chatName?.trim()) {
        metaLabel = chatName.trim();
      } else {
        let fallbackParts: string[] = [];
        try {
          const memberIds = Array.isArray(chatInfo?.members) ? chatInfo!.members!.slice(0, 3) : [];
          const memberNames = await Promise.all(
            memberIds.map(async (id: string) => {
              try {
                const u = await getRingCentralUser({ account, userId: id });
                return u?.firstName?.trim() || null;
              } catch {
                return null;
              }
            }),
          );
          fallbackParts = memberNames.filter((x): x is string => !!x);
        } catch {
          // ignore
        }

        metaLabel = fallbackParts.length > 0 ? fallbackParts.join(", ") : `chat:${chatId}`;
      }

      void core.channel.session
        .recordSessionMetaFromInbound({
          storePath,
          sessionKey: route.sessionKey,
          ctx: core.channel.reply.finalizeInboundContext({
            Provider: "ringcentral",
            Surface: "ringcentral",
            From: `ringcentral:group:${chatId}`,
            To: `ringcentral:${chatId}`,
            OriginatingChannel: "ringcentral",
            OriginatingTo: `ringcentral:${chatId}`,
            ChatType: "channel",
            AccountId: route.accountId,
            SessionKey: route.sessionKey,
            ConversationLabel: metaLabel,
            GroupSpace: metaLabel,
            GroupSubject: metaLabel,
          }),
        })
        .catch((err) => {
          logger.error(`ringcentral: session meta update failed: ${String(err)}`);
        });
    } catch (err) {
      logger.error(`ringcentral: session meta update crashed: ${String(err)}`);
    }
  }

  const dmPolicy = account.config.dm?.policy ?? account.config.dmPolicy ?? "pairing";
  const configAllowFrom = account.config.dm?.allowFrom ?? account.config.allowFrom ?? [];
  const configAllowFromStr = configAllowFrom.map((v) => String(v));
  const shouldComputeAuth = core.channel.commands.shouldComputeCommandAuthorized(rawBody, config);
  const storeAllowFrom =
    !isGroup && (dmPolicy !== "open" || shouldComputeAuth)
      ? await core.channel.pairing.readAllowFromStore("ringcentral").catch(() => [])
      : [];
  const effectiveAllowFrom = [...configAllowFromStr, ...storeAllowFrom];
  const commandAllowFrom = isGroup ? groupUsers.map((v) => String(v)) : effectiveAllowFrom;
  const useAccessGroups = config.commands?.useAccessGroups !== false;
  const senderAllowedForCommands = isSenderAllowed(senderId, commandAllowFrom);
  const commandAuthorized = shouldComputeAuth
    ? core.channel.commands.resolveCommandAuthorizedFromAuthorizers({
        useAccessGroups,
        authorizers: [
          { configured: commandAllowFrom.length > 0, allowed: senderAllowedForCommands },
        ],
      })
    : undefined;

  if (isGroup) {
    const requireMention = groupEntry?.requireMention ?? account.config.requireMention ?? true;
    const mentions = eventBody.mentions ?? [];
    const mentionInfo = extractMentionInfo(mentions, account.config.botExtensionId);
    const allowTextCommands = core.channel.commands.shouldHandleTextCommands({
      cfg: config,
      surface: "ringcentral",
    });
    const mentionGate = resolveMentionGatingWithBypass({
      isGroup: true,
      requireMention,
      canDetectMention: Boolean(account.config.botExtensionId),
      wasMentioned: mentionInfo.wasMentioned,
      implicitMention: false,
      hasAnyMention: mentionInfo.hasAnyMention,
      allowTextCommands,
      hasControlCommand: core.channel.text.hasControlCommand(rawBody, config),
      commandAuthorized: commandAuthorized === true,
    });
    effectiveWasMentioned = mentionGate.effectiveWasMentioned;
    
    // Response decision is now delegated to the AI based on SOUL/identity
    // Plugin only handles mention gating; AI decides whether to respond or NO_REPLY
    
    if (mentionGate.shouldSkip) {
      logVerbose(core, `drop group message (mention required, chat=${chatId})`);
      return;
    }
  }

  // DM policy check
  // - selfOnly=true (default): only Personal chat (self) is allowed (checked above via isPersonalChat)
  // - selfOnly=false: allow DMs based on dmPolicy/allowFrom
  if (!isGroup && !selfOnly) {
    // Non-selfOnly mode: check dmPolicy and allowFrom
    if (dmPolicy === "disabled") {
      logVerbose(core, `ignore DM (dmPolicy=disabled)`);
      return;
    }
    if (dmPolicy === "allowlist" && !isSenderAllowed(senderId, effectiveAllowFrom)) {
      logVerbose(core, `ignore DM from ${senderId} (not in allowFrom)`);
      return;
    }
  }

  if (
    isGroup &&
    core.channel.commands.isControlCommandMessage(rawBody, config) &&
    commandAuthorized !== true
  ) {
    logVerbose(core, `ringcentral: drop control command from ${senderId}`);
    return;
  }

  let mediaPath: string | undefined;
  let mediaType: string | undefined;
  if (attachments.length > 0) {
    const first = attachments[0];
    const attachmentData = await downloadAttachment(first, account, mediaMaxMb, core);
    if (attachmentData) {
      mediaPath = attachmentData.path;
      mediaType = attachmentData.contentType;
    }
  }

  // NOTE: label is set later via conversationLabel (after chatName lookup).
  const storePath = core.channel.session.resolveStorePath(config.session?.store, {
    agentId: route.agentId,
  });
  const envelopeOptions = core.channel.reply.resolveEnvelopeFormatOptions(config);
  const previousTimestamp = core.channel.session.readSessionUpdatedAt({
    storePath,
    sessionKey: route.sessionKey,
  });
  const body = core.channel.reply.formatAgentEnvelope({
    channel: "RingCentral",
    from: isGroup
      ? (chatName?.trim() ? chatName.trim() : `chat:${chatId}`)
      : `user:${senderId}`,
    timestamp: eventBody.creationTime ? Date.parse(eventBody.creationTime) : undefined,
    previousTimestamp,
    envelope: envelopeOptions,
    body: rawBody,
  });

  const groupSystemPrompt = groupConfigResolved.entry?.systemPrompt?.trim() || undefined;

  // Build a better conversation label for sessions/dashboard.
  // - Prefer chatName when available
  // - Fallback to chat:<chatId>
  // NOTE: We intentionally do NOT try to expand members -> display names here yet.
  const conversationLabel = isGroup
    ? (chatName?.trim() ? chatName.trim() : `chat:${chatId}`)
    : `user:${senderId}`;

  // Use openclaw's standard session key format via resolveAgentRoute().
  // Session key format: agent:{agentId}:{channel}:{peerKind}:{peerId}
  // - Group: agent:main:ringcentral:group:{chatId}
  // - Team: agent:main:ringcentral:channel:{chatId}
  // - DM: agent:main:ringcentral:dm:{peerId} (or main session based on dmScope config)
  const ctxPayload = core.channel.reply.finalizeInboundContext({
    Body: body,
    RawBody: rawBody,
    CommandBody: rawBody,
    // IMPORTANT:
    // OpenClaw derives group metadata from ctx.From / ctx.To for group/channel chats.
    From: isGroup ? `ringcentral:${peerKind}:${chatId}` : `ringcentral:${senderId}`,
    // IMPORTANT: use provider/group-prefixed To for group chats so OpenClaw can infer
    // group delivery context and session type correctly.
    To: isGroup ? `ringcentral:${peerKind}:${chatId}` : `ringcentral:${chatId}`,
    SessionKey: route.sessionKey,
    AccountId: route.accountId,
    ChatType: isGroup ? "channel" : "direct",
    ConversationLabel: conversationLabel,
    SenderId: senderId,
    WasMentioned: isGroup ? effectiveWasMentioned : undefined,
    CommandAuthorized: commandAuthorized,
    Provider: "ringcentral",
    Surface: "ringcentral",
    MessageSid: eventBody.id,
    MessageSidFull: eventBody.id,
    MediaPath: mediaPath,
    MediaType: mediaType,
    MediaUrl: mediaPath,
    GroupSpace: isGroup ? (chatName?.trim() ? chatName.trim() : undefined) : undefined,
    // Some cores/providers prefer GroupSubject for label derivation.
    // Set it to chatName to make label resolution more robust.
    GroupSubject: isGroup ? (chatName?.trim() ? chatName.trim() : undefined) : undefined,
    GroupSystemPrompt: isGroup ? groupSystemPrompt : undefined,
    OriginatingChannel: "ringcentral",
    OriginatingTo: isGroup ? `ringcentral:group:${chatId}` : `ringcentral:${chatId}`,
    OriginatingFrom: isGroup ? `ringcentral:group:${chatId}` : `ringcentral:${senderId}`,
  });

  // DEBUG: log critical routing/meta fields to confirm which ctx values are actually being used.
  logger.debug(
    `[default] inbound-meta: isGroup=${isGroup} chatType=${chatType} chatId=${chatId} senderId=${senderId} chatName=${JSON.stringify(
      chatName ?? null,
    )} sessionKey=${route.sessionKey} ctx.From=${ctxPayload.From} ctx.To=${ctxPayload.To} ConversationLabel=${JSON.stringify(
      conversationLabel,
    )}`,
  );

  void core.channel.session
    .recordSessionMetaFromInbound({
      storePath,
      sessionKey: (ctxPayload.SessionKey as string | undefined) ?? route.sessionKey,
      ctx: ctxPayload,
    })
    .catch((err) => {
      logger.error(`ringcentral: failed updating session meta: ${String(err)}`);
    });

  // Backfill / repair session label for existing sessions.
  // Some sessions may have been created earlier with fallback labels (e.g. `chat:<id>`)
  // before we started passing ConversationLabel / GroupSpace.
  try {
    if (isGroup && chatName?.trim()) {
      const repairedLabel = chatName.trim();
      const fallbackLabel = `chat:${chatId}`;

      // If we only have a fallback label, overwrite it with the real group name.
      // NOTE: recordSessionMetaFromInbound merges meta; this second call ensures the
      // dashboard/session list picks up the newer label even for pre-existing sessions.
      // Treat a few common weak labels as eligible for repair.
      // NOTE: core may append ` id:<chatId>` when it falls back to GroupSpace/From.
      const weakLabelCandidates = new Set([
        fallbackLabel,
        `chat:${chatId} id:${chatId}`,
        `ringcentral:group:${chatId}`,
        `ringcentral:group:${chatId} id:${chatId}`,
        String(chatId),
      ]);

      const currentLabel = (conversationLabel || "").trim();

      if (!currentLabel || weakLabelCandidates.has(currentLabel)) {
        void core.channel.session.recordSessionMetaFromInbound({
          storePath,
          sessionKey: (ctxPayload.SessionKey as string | undefined) ?? route.sessionKey,
          ctx: {
            ...ctxPayload,
            ConversationLabel: repairedLabel,
            GroupSubject: repairedLabel,
            GroupSpace: repairedLabel,
          },
        });
      }
    }
  } catch (err) {
    logger.error(`ringcentral: failed repairing session label: ${String(err)}`);
  }

  // Typing indicator disabled - respond directly without "thinking" message

  await core.channel.reply.dispatchReplyWithBufferedBlockDispatcher({
    ctx: ctxPayload,
    cfg: config,
    dispatcherOptions: {
      deliver: async (payload) => {
        await deliverRingCentralReply({
          payload,
          account,
          chatId,
          core,
          config,
          statusSink,
          typingPostId: undefined,
        });
      },
      onError: (err, info) => {
        logger.error(
          `[${account.accountId}] RingCentral ${info.kind} reply failed: ${String(err)}`,
        );
      },
    },
  });
}

async function downloadAttachment(
  attachment: RingCentralAttachment,
  account: ResolvedRingCentralAccount,
  mediaMaxMb: number,
  core: RingCentralCoreRuntime,
): Promise<{ path: string; contentType?: string } | null> {
  const contentUri = attachment.contentUri;
  if (!contentUri) return null;
  const maxBytes = Math.max(1, mediaMaxMb) * 1024 * 1024;
  const downloaded = await downloadRingCentralAttachment({ account, contentUri, maxBytes });
  const saved = await core.channel.media.saveMediaBuffer(
    downloaded.buffer,
    downloaded.contentType ?? attachment.contentType,
    "inbound",
    maxBytes,
    attachment.name,
  );
  return { path: saved.path, contentType: saved.contentType };
}

async function deliverRingCentralReply(params: {
  payload: { text?: string; mediaUrls?: string[]; mediaUrl?: string };
  account: ResolvedRingCentralAccount;
  chatId: string;
  core: RingCentralCoreRuntime;
  config: OpenClawConfig;
  statusSink?: (patch: { lastInboundAt?: number; lastOutboundAt?: number }) => void;
  typingPostId?: string;
}): Promise<void> {
  const { payload, account, chatId, core, config, statusSink, typingPostId } = params;
  const logger = getLogger(core);
  const mediaList = payload.mediaUrls?.length
    ? payload.mediaUrls
    : payload.mediaUrl
      ? [payload.mediaUrl]
      : [];

  if (mediaList.length > 0) {
    let suppressCaption = false;
    if (typingPostId) {
      try {
        await deleteRingCentralMessage({
          account,
          chatId,
          postId: typingPostId,
        });
      } catch (err) {
        const errInfo = formatRcApiError(extractRcApiError(err, account.accountId));
        logger.error(`RingCentral typing cleanup failed: ${errInfo}`);
        const fallbackText = payload.text?.trim()
          ? payload.text
          : mediaList.length > 1
            ? "Sent attachments."
            : "Sent attachment.";
        try {
          await updateRingCentralMessage({
            account,
            chatId,
            postId: typingPostId,
            text: fallbackText,
          });
          suppressCaption = Boolean(payload.text?.trim());
        } catch (updateErr) {
          const updateErrInfo = formatRcApiError(extractRcApiError(updateErr, account.accountId));
          logger.error(`RingCentral typing update failed: ${updateErrInfo}`);
        }
      }
    }
    let first = true;
    for (const mediaUrl of mediaList) {
      const caption = first && !suppressCaption ? payload.text : undefined;
      first = false;
      try {
        const loaded = await core.channel.media.fetchRemoteMedia(mediaUrl, {
          maxBytes: (account.config.mediaMaxMb ?? 20) * 1024 * 1024,
        });
        const upload = await uploadRingCentralAttachment({
          account,
          chatId,
          filename: loaded.filename ?? "attachment",
          buffer: loaded.buffer,
          contentType: loaded.contentType,
        });
        if (!upload.attachmentId) {
          throw new Error("missing attachment id");
        }
        const sendResult = await sendRingCentralMessage({
          account,
          chatId,
          text: caption,
          attachments: [{ id: upload.attachmentId }],
        });
        if (sendResult?.postId) trackSentMessageId(sendResult.postId);
        statusSink?.({ lastOutboundAt: Date.now() });
      } catch (err) {
        const errInfo = formatRcApiError(extractRcApiError(err, account.accountId));
        logger.error(`RingCentral attachment send failed: ${errInfo}`);
      }
    }
    return;
  }

  if (payload.text) {
    const chunkLimit = account.config.textChunkLimit ?? 4000;
    const chunkMode = core.channel.text.resolveChunkMode(
      config,
      "ringcentral",
      account.accountId,
    );
    const chunks = core.channel.text.chunkMarkdownTextWithMode(
      payload.text,
      chunkLimit,
      chunkMode,
    );
    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      try {
        if (i === 0 && typingPostId) {
          const updateResult = await updateRingCentralMessage({
            account,
            chatId,
            postId: typingPostId,
            text: chunk,
          });
          if (updateResult?.postId) trackSentMessageId(updateResult.postId);
        } else {
          const sendResult = await sendRingCentralMessage({
            account,
            chatId,
            text: chunk,
          });
          if (sendResult?.postId) trackSentMessageId(sendResult.postId);
        }
        statusSink?.({ lastOutboundAt: Date.now() });
      } catch (err) {
        const errInfo = formatRcApiError(extractRcApiError(err, account.accountId));
        logger.error(`RingCentral message send failed: ${errInfo}`);
      }
    }
  }
}

export async function startRingCentralMonitor(
  options: RingCentralMonitorOptions,
): Promise<() => void> {
  const { account, config, runtime, abortSignal, statusSink } = options;
  const core = getRingCentralRuntime();
  const logger = createLogger(core);

  let wsSubscription: Awaited<ReturnType<ReturnType<InstanceType<typeof Subscriptions>["createSubscription"]>["register"]>> | null = null;
  let reconnectAttempts = 0;
  let reconnectTimeout: ReturnType<typeof setTimeout> | null = null;
  let isShuttingDown = false;
  let ownerId: string | undefined;

  // Avoid hammering /oauth/wstoken (auth rate limit is very low, e.g. 5/min).
  let nextAllowedWsConnectAt = 0;

  // Calculate delay with exponential backoff
  const getReconnectDelay = () => {
    const delay = Math.min(
      RECONNECT_INITIAL_DELAY * Math.pow(2, reconnectAttempts),
      RECONNECT_MAX_DELAY
    );
    return delay;
  };

  // Create and setup subscription
  const createSubscription = async (): Promise<void> => {
    if (isShuttingDown || abortSignal.aborted) return;

    logger.info(`[${account.accountId}] Starting RingCentral WebSocket subscription...`);

    if (Date.now() < nextAllowedWsConnectAt) {
      const waitMs = nextAllowedWsConnectAt - Date.now();
      logger.warn(
        `[${account.accountId}] WS connect is rate-limited locally; will retry in ${Math.ceil(waitMs / 1000)}s`,
      );
      scheduleReconnect();
      return;
    }

    if (Date.now() < nextAllowedWsConnectAt) {
      const waitMs = nextAllowedWsConnectAt - Date.now();
      logger.warn(
        `[${account.accountId}] WS connect is rate-limited locally; will retry in ${Math.ceil(waitMs / 1000)}s`,
      );
      scheduleReconnect();
      return;
    }

    try {
      // Get or create WS manager (singleton per account)
      const mgr = await getOrCreateWsManager(account, logger);

      // Force connect once per account (with in-flight de-dupe)
      await ensureWsConnected(mgr, account, logger);

      const subscription = mgr.subscriptions.createSubscription();

      // IMPORTANT: @ringcentral/subscriptions will create *its own* WS extension instance internally
      // when calling subscription.register(), which can still lead to `wse.ws` undefined and
      // addEventListener crash. We bypass it by using our singleton wsExt directly.
      // We'll keep `subscription` object for event emitter convenience, but registration uses wsExt.


      // Extra diagnostics: log versions so we can pin a working combo.
      try {
        // @ts-ignore - dynamic import of package.json for version logging
        const sdkVer = (await import("@ringcentral/sdk/package.json", { with: { type: "json" } } as any))?.default?.version;
        // @ts-ignore - dynamic import of package.json for version logging
        const subsVer = (await import("@ringcentral/subscriptions/package.json", { with: { type: "json" } } as any))?.default?.version;
        logger.debug(`[${account.accountId}] rc sdk versions: @ringcentral/sdk=${sdkVer} @ringcentral/subscriptions=${subsVer}`);
      } catch {
        // ignore
      }

      // Determine ownerId (the JWT user's extension id) for self-message filtering.
      // Prefer local config (no network) to avoid rate limiting.
      // Fallback to REST only when needed.
      if (!ownerId) {
        const allowFrom =
          (account.config.dm?.allowFrom ?? account.config.allowFrom ?? []).map((v) => String(v));
        const allowFromFirst = allowFrom[0]?.trim();

        // If allowFrom[0] is configured, treat it as the current user id.
        // (This is consistent with your setup where you put your own id in allowFrom.)
        if (allowFromFirst) {
          ownerId = allowFromFirst;
          logger.debug(`[${account.accountId}] ownerId set from config allowFrom[0]: ${ownerId}`);
        }
      }

      // Fallback: query current extension via REST (may be rate-limited)
      if (!ownerId) {
        try {
          const platform = mgr.sdk.platform();
          const response = await platform.get("/restapi/v1.0/account/~/extension/~");
          const userInfo = await response.json();
          ownerId = userInfo?.id?.toString();
          logger.info(`[${account.accountId}] Authenticated as extension (REST): ${ownerId}`);
        } catch (err) {
          const msg = String(err);
          logger.error(
            `[${account.accountId}] Failed to get current user (REST, best-effort): ${msg}. ` +
              `Continuing without ownerId; self-message filtering may be degraded temporarily.`,
          );
          // Backoff a bit to avoid hammering
          nextAllowedWsConnectAt = Date.now() + 60_000;
        }
      }

      // Handle notifications
      subscription.on(subscription.events.notification, (event: unknown) => {
        logger.debug(`WebSocket notification received: ${JSON.stringify(event)}`);
        const evt = event as RingCentralWebhookEvent;
        processWebSocketEvent({
          event: evt,
          account,
          config,
          runtime,
          core,
          statusSink,
          ownerId,
        }).catch((err) => {
          logger.error(`[${account.accountId}] WebSocket event processing failed: ${String(err)}`);
        });
      });

      // Subscribe to Team Messaging events and save WsSubscription for cleanup
      // IMPORTANT:
      // We use Team Messaging API (/team-messaging/v1/...) for fetching chats/persons.
      // So our push subscription should also follow Team Messaging event filters.
      // The older /glip/* filters can yield 404s depending on account/permissions and
      // can break inbound processing.
      const eventFilters = [
        "/restapi/v1.0/glip/posts",
        "/restapi/v1.0/glip/groups",
      ];

      // Register subscription via singleton wsExt (NOT via @ringcentral/subscriptions.register()).
      // This avoids newWsExtension() being created per call.
      wsSubscription = await mgr.wsExt.subscribe(eventFilters, (event: unknown) => {
        subscription.emit(subscription.events.notification, event);
      });
      
      logger.info(`[${account.accountId}] RingCentral WebSocket subscription established`);
      reconnectAttempts = 0; // Reset on success

      // Setup WebSocket close/error handlers for auto-reconnect
      const ws = mgr.wsExt.ws;
      if (ws) {
        const handleWsClose = (event: { code?: number; reason?: string } | Event) => {
          if (isShuttingDown || abortSignal.aborted) return;
          const closeEvent = event as { code?: number; reason?: string };
          logger.warn(
            `[${account.accountId}] WebSocket closed unexpectedly. ` +
              `code=${closeEvent.code ?? "unknown"} reason=${closeEvent.reason ?? "none"}. ` +
              `Scheduling reconnect...`,
          );
          // Clear WsManager cache to force fresh connection
          wsManagers.delete(account.accountId);
          scheduleReconnect();
        };

        const handleWsError = (event: unknown) => {
          if (isShuttingDown || abortSignal.aborted) return;
          const errEvent = event as { message?: string };
          const errMsg = errEvent?.message ?? "WebSocket error";
          logger.error(`[${account.accountId}] WebSocket error: ${errMsg}`);
          // Error usually followed by close, so we don't reconnect here directly
        };

        ws.addEventListener("close", handleWsClose);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (ws as any).addEventListener("error", handleWsError);

        logger.debug(`[${account.accountId}] WebSocket close/error handlers registered`);
      }

    } catch (err) {
      const e = err as any;
      const errStr = String(err);
      const msg = e?.stack ? String(e.stack) : errStr;

      // Check for auth errors - don't retry on auth failures
      const isAuthError = errStr.includes("401") || errStr.includes("Unauthorized") || errStr.includes("invalid_grant");
      if (isAuthError) {
        logger.error(`[${account.accountId}] Authentication failed. Please check your credentials.`);
        return;
      }

      // If we hit auth rate limit for /oauth/wstoken, back off according to retry-after.
      const retryAfterHeader =
        typeof e?.response?.headers?.get === "function" ? e.response.headers.get("retry-after") :
        typeof e?.response?.headers?.["retry-after"] === "string" ? e.response.headers["retry-after"] :
        undefined;
      const retryAfterMs =
        typeof e?.retryAfter === "number" ? e.retryAfter :
        (retryAfterHeader ? (parseInt(retryAfterHeader, 10) * 1000) : undefined);

      const isRateLimited = e?.message === "Request rate exceeded" || e?.response?.status === 429 ||
        errStr.includes("429") || errStr.includes("rate") || errStr.includes("Rate");

      if (isRateLimited) {
        const backoffMs = Number.isFinite(retryAfterMs) && retryAfterMs! > 0 ? retryAfterMs! : 60000;
        nextAllowedWsConnectAt = Date.now() + backoffMs;
        logger.error(
          `[${account.accountId}] WS connect failed due to rate limit (wstoken). ` +
            `Backing off for ${Math.ceil(backoffMs / 1000)}s before retrying.`,
        );
      }

      logger.error(
        `[default] WS subscription failed (NO WS push will be received until fixed). ` +
          `accountId=${account.accountId}. ` +
          `Reason=${e?.name ?? 'Error'}: ${e?.message ?? errStr}\n` +
          `Where=createSubscription()->wsExt.subscribe()\n` +
          `LikelyCause: underlying WebSocket object does not implement addEventListener (required by @rc-ex/ws), OR ws connect failed earlier and was swallowed.\n` +
          `EventFilters=${JSON.stringify([
            "/restapi/v1.0/glip/posts",
            "/restapi/v1.0/glip/groups",
          ])}\n` +
          `Stack:\n${msg}`,
      );
      scheduleReconnect(isRateLimited);
    }
  };

  // Schedule reconnection with exponential backoff
  const scheduleReconnect = (isRateLimited = false) => {
    if (isShuttingDown || abortSignal.aborted) return;
    if (reconnectAttempts >= RECONNECT_MAX_ATTEMPTS) {
      logger.error(`[${account.accountId}] Max reconnection attempts (${RECONNECT_MAX_ATTEMPTS}) reached. Giving up.`);
      return;
    }

    // Use longer delay if rate limited
    const baseDelay = isRateLimited ? RATE_LIMIT_BACKOFF : getReconnectDelay();
    const delay = Math.min(baseDelay, RECONNECT_MAX_DELAY);
    reconnectAttempts++;
    logger.warn(`[${account.accountId}] Scheduling reconnection attempt ${reconnectAttempts}/${RECONNECT_MAX_ATTEMPTS} in ${delay}ms${isRateLimited ? " (rate limited)" : ""}...`);

    // Clean up existing WsSubscription
    if (wsSubscription) {
      wsSubscription.revoke().catch(() => {});
      wsSubscription = null;
    }

    reconnectTimeout = setTimeout(() => {
      reconnectTimeout = null;
      createSubscription().catch((err) => {
        logger.error(`[${account.accountId}] Reconnection failed: ${String(err)}`);
      });
    }, delay);
  };

  // Initial connection
  await createSubscription();

  // Start chat cache sync
  const workspace = account.config.workspace ?? (config.agents as any)?.defaults?.workspace;
  startChatCacheSync({
    account,
    workspace: workspace as string | undefined,
    logger,
    abortSignal,
  });

  // Handle abort signal
  const cleanup = () => {
    isShuttingDown = true;
    logger.info(`[${account.accountId}] Stopping RingCentral WebSocket subscription...`);
    
    stopChatCacheSync();

    if (reconnectTimeout) {
      clearTimeout(reconnectTimeout);
      reconnectTimeout = null;
    }
    
    if (wsSubscription) {
      wsSubscription.revoke().catch((err) => {
        logger.error(`[${account.accountId}] Failed to revoke subscription: ${String(err)}`);
      });
      wsSubscription = null;
    }
  };

  if (abortSignal.aborted) {
    cleanup();
  } else {
    abortSignal.addEventListener("abort", cleanup, { once: true });
  }

  return cleanup;
}

/**
 * Clear cached WebSocket manager for a specific account.
 * This should be called when logging out an account to ensure
 * fresh connections are created on next login.
 *
 * @param accountId - The account ID to clear from cache
 * @returns true if a cached manager was found and removed, false otherwise
 */
export function clearRingCentralWsManager(accountId: string): boolean {
  const manager = wsManagers.get(accountId);
  if (!manager) {
    return false;
  }

  // Attempt to close the WebSocket connection gracefully
  try {
    const ws = manager.wsExt?.ws;
    if (ws && typeof ws.close === "function") {
      ws.close();
    }
  } catch {
    // Ignore errors during cleanup
  }

  // Remove from cache
  wsManagers.delete(accountId);
  return true;
}

/**
 * Clear all cached WebSocket managers.
 * Useful for complete cleanup during shutdown.
 */
export function clearAllRingCentralWsManagers(): void {
  for (const [accountId] of wsManagers) {
    clearRingCentralWsManager(accountId);
  }
}
